{"meta":{"title":"董先生的博客","subtitle":"一天进步一点","description":"技术至上","author":"董先生","url":"https://smile-dyg.github.io","root":"/"},"pages":[{"title":"所有标签","date":"2020-06-06T03:30:59.565Z","updated":"2020-06-06T03:30:51.763Z","comments":true,"path":"tags/index.html","permalink":"https://smile-dyg.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-06-06T04:17:45.765Z","updated":"2020-06-06T04:17:38.133Z","comments":true,"path":"about/index.html","permalink":"https://smile-dyg.github.io/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有分类","date":"2020-06-06T04:20:55.369Z","updated":"2020-06-06T04:20:49.706Z","comments":true,"path":"categories/index.html","permalink":"https://smile-dyg.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"每日一题 验证回文串","slug":"leetcode-125","date":"2020-06-19T15:44:14.000Z","updated":"2020-06-19T15:47:50.670Z","comments":true,"path":"2020/06/19/leetcode-125/","link":"","permalink":"https://smile-dyg.github.io/2020/06/19/leetcode-125/","excerpt":"给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。","text":"给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: “A man, a plan, a canal: Panama”输出: true示例 2: 输入: “race a car”输出: false 代码如下： class Solution { public: bool isPalindrome(string s) { ​ string sgood; ​ for (char ch: s) { ​ if (isalnum(ch)) { ​ sgood += tolower(ch); ​ } ​ } ​ string sgood_rev(sgood.rbegin(), sgood.rend()); ​ return sgood == sgood_rev; } };","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://smile-dyg.github.io/tags/leetcode/"}]},{"title":"每日一题 最佳观光组合","slug":"leetcode-1014","date":"2020-06-17T15:37:14.000Z","updated":"2020-06-17T15:41:14.018Z","comments":true,"path":"2020/06/17/leetcode-1014/","link":"","permalink":"https://smile-dyg.github.io/2020/06/17/leetcode-1014/","excerpt":"给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。 一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。 返回一对观光景点能取得的最高分。","text":"给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。 一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。 返回一对观光景点能取得的最高分。 示例： 输入：[8,1,5,2,6]输出：11解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11 提示： 2 &lt;= A.length &lt;= 500001 &lt;= A[i] &lt;= 1000 代码如下： class Solution { public: int maxScoreSightseeingPair(vector&amp; A) { ​ int ans = 0, mx = A[0] + 0; ​ for (int j = 1; j &lt; A.size(); ++j) { ​ ans = max(ans, mx + A[j] - j); ​ // 边遍历边维护 ​ mx = max(mx, A[j] + j); ​ } ​ return ans; } };","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://smile-dyg.github.io/tags/leetcode/"}]},{"title":"每日一题 二叉树的序列化与反序列化","slug":"leetcode-297","date":"2020-06-16T14:26:27.000Z","updated":"2020-06-16T14:55:22.909Z","comments":true,"path":"2020/06/16/leetcode-297/","link":"","permalink":"https://smile-dyg.github.io/2020/06/16/leetcode-297/","excerpt":"序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。","text":"序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 示例: 你可以将以下二叉树： ​ 1 / 2 3 / 4 5 序列化为 “[1,2,3,null,null,4,5]” 提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。 代码如下： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Codec { public: string serialize(TreeNode* root) { ​ if (!root) return “X”; ​ auto l = “(“ + serialize(root-&gt;left) + “)”; ​ auto r = “(“ + serialize(root-&gt;right) + “)”; ​ return l + to_string(root-&gt;val) + r; } inline TreeNode* parseSubtree(const string &amp;data, int &amp;ptr) { ​ ++ptr; // 跳过左括号 ​ auto subtree = parse(data, ptr); ​ ++ptr; // 跳过右括号 ​ return subtree; } inline int parseInt(const string &amp;data, int &amp;ptr) { ​ int x = 0, sgn = 1; ​ if (!isdigit(data[ptr])) { ​ sgn = -1; ​ ++ptr; ​ } ​ while (isdigit(data[ptr])) { ​ x = x * 10 + data[ptr++] - ‘0’; ​ } ​ return x * sgn; } TreeNode* parse(const string &amp;data, int &amp;ptr) { ​ if (data[ptr] == ‘X’) { ​ ++ptr; ​ return nullptr; ​ } ​ auto cur = new TreeNode(0); ​ cur-&gt;left = parseSubtree(data, ptr); ​ cur-&gt;val = parseInt(data, ptr); ​ cur-&gt;right = parseSubtree(data, ptr); ​ return cur; } TreeNode* deserialize(string data) { ​ int ptr = 0; ​ return parse(data, ptr); } }; // Your Codec object will be instantiated and called as such: // Codec codec; // codec.deserialize(codec.serialize(root));","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://smile-dyg.github.io/tags/leetcode/"}]},{"title":"每日一题 最长公共前缀","slug":"leetcode-14","date":"2020-06-15T12:18:46.000Z","updated":"2020-06-15T12:20:52.091Z","comments":true,"path":"2020/06/15/leetcode-14/","link":"","permalink":"https://smile-dyg.github.io/2020/06/15/leetcode-14/","excerpt":"编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。","text":"编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1: 输入: [“flower”,”flow”,”flight”]输出: “fl”示例 2: 输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入不存在公共前缀。 代码如下： class Solution { public: string longestCommonPrefix(vector&amp; strs) { ​ if (!strs.size()) { ​ return “”; ​ } ​ string prefix = strs[0]; ​ int count = strs.size(); ​ for (int i = 1; i &lt; count; ++i) { ​ prefix = longestCommonPrefix(prefix, strs[i]); ​ if (!prefix.size()) { ​ break; ​ } ​ } ​ return prefix; } string longestCommonPrefix(const string&amp; str1, const string&amp; str2) { ​ int length = min(str1.size(), str2.size()); ​ int index = 0; ​ while (index &lt; length &amp;&amp; str1[index] == str2[index]) { ​ ++index; ​ } ​ return str1.substr(0, index); } };","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://smile-dyg.github.io/tags/leetcode/"}]},{"title":"每日一题 转变数组后最接近目标值的数组和","slug":"leetcode-1300","date":"2020-06-14T15:37:40.000Z","updated":"2020-06-14T15:39:25.952Z","comments":true,"path":"2020/06/14/leetcode-1300/","link":"","permalink":"https://smile-dyg.github.io/2020/06/14/leetcode-1300/","excerpt":"给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近 target （最接近表示两者之差的绝对值最小）。 如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。 请注意，答案不一定是 arr 中的数字。","text":"给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近 target （最接近表示两者之差的绝对值最小）。 如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。 请注意，答案不一定是 arr 中的数字。 示例 1： 输入：arr = [4,9,3], target = 10输出：3解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。示例 2： 输入：arr = [2,3,5], target = 10输出：5示例 3： 输入：arr = [60864,25176,27249,21296,20204], target = 56803输出：11361 提示： 1 &lt;= arr.length &lt;= 10^41 &lt;= arr[i], target &lt;= 10^5 代码如下： class Solution { public: int findBestValue(vector&amp; arr, int target) { ​ sort(arr.begin(), arr.end()); ​ int n = arr.size(); ​ vector prefix(n + 1); ​ for (int i = 1; i &lt;= n; ++i) { ​ prefix[i] = prefix[i - 1] + arr[i - 1]; ​ } ​ int r = *max_element(arr.begin(), arr.end()); ​ int ans = 0, diff = target; ​ for (int i = 1; i &lt;= r; ++i) { ​ auto iter = lower_bound(arr.begin(), arr.end(), i); ​ int cur = prefix[iter - arr.begin()] + (arr.end() - iter) * i; ​ if (abs(cur - target) &lt; diff) { ​ ans = i; ​ diff = abs(cur - target); ​ } ​ } ​ return ans; } };","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://smile-dyg.github.io/tags/leetcode/"}]},{"title":"每日一题 爬楼梯","slug":"leetcode-70","date":"2020-06-13T15:38:48.000Z","updated":"2020-06-13T15:41:16.617Z","comments":true,"path":"2020/06/13/leetcode-70/","link":"","permalink":"https://smile-dyg.github.io/2020/06/13/leetcode-70/","excerpt":"假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。","text":"假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2输出： 2解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶示例 2： 输入： 3输出： 3解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 代码如下： class Solution { public: int climbStairs(int n) { ​ int p = 0, q = 0, r = 1; ​ for (int i = 1; i &lt;= n; ++i) { ​ p = q; ​ q = r; ​ r = p + q; ​ } ​ return r; } };","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://smile-dyg.github.io/tags/leetcode/"}]},{"title":"每日一题 三数之和","slug":"leetcode-15","date":"2020-06-12T15:40:22.000Z","updated":"2020-06-12T15:44:13.013Z","comments":true,"path":"2020/06/12/leetcode-15/","link":"","permalink":"https://smile-dyg.github.io/2020/06/12/leetcode-15/","excerpt":"给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。","text":"给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 代码如下： class Solution { public: vector&lt;vector&gt; threeSum(vector&amp; nums) { ​ int n = nums.size(); ​ sort(nums.begin(), nums.end()); ​ vector&lt;vector&gt; ans; ​ // 枚举 a ​ for (int first = 0; first &lt; n; ++first) { ​ // 需要和上一次枚举的数不相同 ​ if (first &gt; 0 &amp;&amp; nums[first] == nums[first - 1]) { ​ continue; ​ } ​ // c 对应的指针初始指向数组的最右端 ​ int third = n - 1; ​ int target = -nums[first]; ​ // 枚举 b ​ for (int second = first + 1; second &lt; n; ++second) { ​ // 需要和上一次枚举的数不相同 ​ if (second &gt; first + 1 &amp;&amp; nums[second] == nums[second - 1]) { ​ continue; ​ } ​ // 需要保证 b 的指针在 c 的指针的左侧 ​ while (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) { ​ –third; ​ } ​ // 如果指针重合，随着 b 后续的增加 ​ // 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环 ​ if (second == third) { ​ break; ​ } ​ if (nums[second] + nums[third] == target) { ​ ans.push_back({nums[first], nums[second], nums[third]}); ​ } ​ } ​ } ​ return ans; } };","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://smile-dyg.github.io/tags/leetcode/"}]},{"title":"每日一题 每日温度","slug":"leetcode-739","date":"2020-06-11T15:42:26.000Z","updated":"2020-06-11T15:49:53.827Z","comments":true,"path":"2020/06/11/leetcode-739/","link":"","permalink":"https://smile-dyg.github.io/2020/06/11/leetcode-739/","excerpt":"请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。","text":"请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 代码如下： class Solution { public: vector dailyTemperatures(vector&amp; T) { ​ int n = T.size(); ​ vector ans(n), next(101, INT_MAX); ​ for (int i = n - 1; i &gt;= 0; –i) { ​ int warmerIndex = INT_MAX; ​ for (int t = T[i] + 1; t &lt;= 100; ++t) { ​ warmerIndex = min(warmerIndex, next[t]); ​ } ​ if (warmerIndex != INT_MAX) { ​ ans[i] = warmerIndex - i; ​ } ​ next[T[i]] = i; ​ } ​ return ans; } };","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://smile-dyg.github.io/tags/leetcode/"}]},{"title":"每日一题 回文数","slug":"leetcode-9","date":"2020-06-10T15:45:45.000Z","updated":"2020-06-10T15:48:05.385Z","comments":true,"path":"2020/06/10/leetcode-9/","link":"","permalink":"https://smile-dyg.github.io/2020/06/10/leetcode-9/","excerpt":"判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。","text":"判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121输出: true示例 2: 输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。示例 3: 输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 代码如下： class Solution { public: bool isPalindrome(int x) { ​ // 特殊情况： ​ // 如上所述，当 x &lt; 0 时，x 不是回文数。 ​ // 同样地，如果数字的最后一位是 0，为了使该数字为回文， ​ // 则其第一位数字也应该是 0 ​ // 只有 0 满足这一属性 ​ if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) { ​ return false; ​ } ​ int revertedNumber = 0; ​ while (x &gt; revertedNumber) { ​ revertedNumber = revertedNumber * 10 + x % 10; ​ x /= 10; ​ } ​ // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 ​ // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， ​ // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 ​ return x == revertedNumber || x == revertedNumber / 10; } };","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://smile-dyg.github.io/tags/leetcode/"}]},{"title":"每日一题 单词接龙II","slug":"leetcode-126","date":"2020-06-07T15:49:05.000Z","updated":"2020-06-07T15:54:26.833Z","comments":true,"path":"2020/06/07/leetcode-126/","link":"","permalink":"https://smile-dyg.github.io/2020/06/07/leetcode-126/","excerpt":"题目描述：给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则： 每次转换只能改变一个字母。转换过程中的中间单词必须是字典中的单词。","text":"题目描述：给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则： 每次转换只能改变一个字母。转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回一个空列表。所有单词具有相同的长度。所有单词只由小写字母组成。字典中不存在重复的单词。你可以假设 beginWord 和 endWord 是非空的，且二者不相同。示例 1: 输入:beginWord = “hit”,endWord = “cog”,wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”] 输出:[ [“hit”,”hot”,”dot”,”dog”,”cog”], [“hit”,”hot”,”lot”,”log”,”cog”]]示例 2: 输入:beginWord = “hit”endWord = “cog”wordList = [“hot”,”dot”,”dog”,”lot”,”log”] 输出: [] 解释: endWord “cog” 不在字典中，所以不存在符合要求的转换序列。 后续待更新","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://smile-dyg.github.io/tags/leetcode/"}]},{"title":"每日一题 最长连续序列","slug":"leetcode-128","date":"2020-06-06T03:07:10.000Z","updated":"2020-06-06T03:15:42.873Z","comments":true,"path":"2020/06/06/leetcode-128/","link":"","permalink":"https://smile-dyg.github.io/2020/06/06/leetcode-128/","excerpt":"题目描述：给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为O(n)。","text":"题目描述：给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为O(n)。 示例： 输入：[100, 4, 200, 1, 3, 2] 输出：4 解释：最长连续序列是[1, 2, 3, 4]。它的长度为4。 1234567891011121314151617181920212223242526class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; num_set; //遍历整个数组，去重 for(const int&amp; num:nums) &#123; num_set.insert(num); &#125; int longestStreak = 0; for(const int&amp; num : num_set) &#123; if(!num_set.count(num-1)) &#123; int currentNum = num; int currentStreak = 1; while(num_set.count(currentNum+1)) &#123; currentNum += 1; currentStreak += 1; &#125; longestStreak = max(longestStreak,currentStreak); &#125; &#125; return longestStreak; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://smile-dyg.github.io/tags/leetcode/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-05T14:44:58.064Z","updated":"2020-05-06T03:54:42.907Z","comments":true,"path":"2020/05/05/hello-world/","link":"","permalink":"https://smile-dyg.github.io/2020/05/05/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://smile-dyg.github.io/tags/leetcode/"}]}