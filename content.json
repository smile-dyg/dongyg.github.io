{"meta":{"title":"董先生的博客","subtitle":"一天进步一点","description":"技术至上","author":"董先生","url":"https://smile-dyg.github.io","root":"/"},"pages":[{"title":"所有标签","date":"2020-06-06T03:30:59.565Z","updated":"2020-06-06T03:30:51.763Z","comments":true,"path":"tags/index.html","permalink":"https://smile-dyg.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-06-06T04:17:45.765Z","updated":"2020-06-06T04:17:38.133Z","comments":true,"path":"about/index.html","permalink":"https://smile-dyg.github.io/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有分类","date":"2020-06-06T04:20:55.369Z","updated":"2020-06-06T04:20:49.706Z","comments":true,"path":"categories/index.html","permalink":"https://smile-dyg.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"每日一题 每日温度","slug":"leetcode-739","date":"2020-06-11T15:42:26.000Z","updated":"2020-06-11T15:49:53.827Z","comments":true,"path":"2020/06/11/leetcode-739/","link":"","permalink":"https://smile-dyg.github.io/2020/06/11/leetcode-739/","excerpt":"请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。","text":"请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 代码如下： class Solution { public: vector dailyTemperatures(vector&amp; T) { ​ int n = T.size(); ​ vector ans(n), next(101, INT_MAX); ​ for (int i = n - 1; i &gt;= 0; –i) { ​ int warmerIndex = INT_MAX; ​ for (int t = T[i] + 1; t &lt;= 100; ++t) { ​ warmerIndex = min(warmerIndex, next[t]); ​ } ​ if (warmerIndex != INT_MAX) { ​ ans[i] = warmerIndex - i; ​ } ​ next[T[i]] = i; ​ } ​ return ans; } };","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://smile-dyg.github.io/tags/leetcode/"}]},{"title":"每日一题 回文数","slug":"leetcode-9","date":"2020-06-10T15:45:45.000Z","updated":"2020-06-10T15:48:05.385Z","comments":true,"path":"2020/06/10/leetcode-9/","link":"","permalink":"https://smile-dyg.github.io/2020/06/10/leetcode-9/","excerpt":"判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。","text":"判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121输出: true示例 2: 输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。示例 3: 输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 代码如下： class Solution { public: bool isPalindrome(int x) { ​ // 特殊情况： ​ // 如上所述，当 x &lt; 0 时，x 不是回文数。 ​ // 同样地，如果数字的最后一位是 0，为了使该数字为回文， ​ // 则其第一位数字也应该是 0 ​ // 只有 0 满足这一属性 ​ if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) { ​ return false; ​ } ​ int revertedNumber = 0; ​ while (x &gt; revertedNumber) { ​ revertedNumber = revertedNumber * 10 + x % 10; ​ x /= 10; ​ } ​ // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 ​ // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， ​ // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 ​ return x == revertedNumber || x == revertedNumber / 10; } };","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://smile-dyg.github.io/tags/leetcode/"}]},{"title":"每日一题 单词接龙II","slug":"leetcode-126","date":"2020-06-07T15:49:05.000Z","updated":"2020-06-07T15:54:26.833Z","comments":true,"path":"2020/06/07/leetcode-126/","link":"","permalink":"https://smile-dyg.github.io/2020/06/07/leetcode-126/","excerpt":"题目描述：给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则： 每次转换只能改变一个字母。转换过程中的中间单词必须是字典中的单词。","text":"题目描述：给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则： 每次转换只能改变一个字母。转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回一个空列表。所有单词具有相同的长度。所有单词只由小写字母组成。字典中不存在重复的单词。你可以假设 beginWord 和 endWord 是非空的，且二者不相同。示例 1: 输入:beginWord = “hit”,endWord = “cog”,wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”] 输出:[ [“hit”,”hot”,”dot”,”dog”,”cog”], [“hit”,”hot”,”lot”,”log”,”cog”]]示例 2: 输入:beginWord = “hit”endWord = “cog”wordList = [“hot”,”dot”,”dog”,”lot”,”log”] 输出: [] 解释: endWord “cog” 不在字典中，所以不存在符合要求的转换序列。 后续待更新","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://smile-dyg.github.io/tags/leetcode/"}]},{"title":"每日一题 最长连续序列","slug":"leetcode-128","date":"2020-06-06T03:07:10.000Z","updated":"2020-06-06T03:15:42.873Z","comments":true,"path":"2020/06/06/leetcode-128/","link":"","permalink":"https://smile-dyg.github.io/2020/06/06/leetcode-128/","excerpt":"题目描述：给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为O(n)。","text":"题目描述：给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为O(n)。 示例： 输入：[100, 4, 200, 1, 3, 2] 输出：4 解释：最长连续序列是[1, 2, 3, 4]。它的长度为4。 1234567891011121314151617181920212223242526class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; num_set; //遍历整个数组，去重 for(const int&amp; num:nums) &#123; num_set.insert(num); &#125; int longestStreak = 0; for(const int&amp; num : num_set) &#123; if(!num_set.count(num-1)) &#123; int currentNum = num; int currentStreak = 1; while(num_set.count(currentNum+1)) &#123; currentNum += 1; currentStreak += 1; &#125; longestStreak = max(longestStreak,currentStreak); &#125; &#125; return longestStreak; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://smile-dyg.github.io/tags/leetcode/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-05T14:44:58.064Z","updated":"2020-05-06T03:54:42.907Z","comments":true,"path":"2020/05/05/hello-world/","link":"","permalink":"https://smile-dyg.github.io/2020/05/05/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://smile-dyg.github.io/tags/leetcode/"}]}